# This file is auto-generated by misc/exports_to_py.py
# DO NOT edit this file manually!
# To regenerate this file, run:
#     python misc/exports_to_py.py

from functools import lru_cache
from .TieError import *


class TieAPIError(RuntimeError):
    def __init__(self, err, ex):
        self.err = err
        self.ex = ex

    def __str__(self):
        return str(self.ex)


tie_last_exception = None


def set_last_exception(exc):
    global tie_last_exception
    tie_last_exception = exc


def get_and_clear_last_exception(err, _):
    global tie_last_exception
    exc = tie_last_exception
    tie_last_exception = None
    return TieAPIError(err, exc)


TIE_ERROR_TO_PYTHON_EXCEPTION = {
    TIE_ERROR_INVALID_ARGUMENT: TieAPIError,
    TIE_ERROR_INVALID_RETURN_ARG: TieAPIError,
    TIE_ERROR_INVALID_HANDLE: TieAPIError,
    TIE_ERROR_INVALID_INDEX: TieAPIError,
    TIE_ERROR_TAICHI_TYPE_ERROR: TieAPIError,
    TIE_ERROR_TAICHI_SYNTAX_ERROR: TieAPIError,
    TIE_ERROR_TAICHI_INDEX_ERROR: TieAPIError,
    TIE_ERROR_TAICHI_RUNTIME_ERROR: TieAPIError,
    TIE_ERROR_TAICHI_ASSERTION_ERROR: TieAPIError,
    TIE_ERROR_CALLBACK_FAILED: get_and_clear_last_exception,
    TIE_ERROR_OUT_OF_MEMORY: TieAPIError,
    TIE_ERROR_UNKNOWN_CXX_EXCEPTION: TieAPIError,
}


TIE_TEMP_CCORE_TYPE_TO_CORE_TYPE = {
    "ASTBuilder": "taichi._lib.core.ASTBuilder",
    "DataType": "taichi._lib.core.DataType",
    "AotModuleBuilder": "taichi._lib.core.AotModuleBuilder",
    "SNode": "taichi._lib.core.SNode",
    "SparseMatrix": "taichi._lib.core.SparseMatrix",
    "Ndarray": "taichi._lib.core.Ndarray",
    "Texture": "taichi._lib.core.Texture",
    "CompiledKernelData": "taichi._lib.core.CompiledKernelData",
}


def get_exception_to_throw_if_not_success(ret, get_last_error):
    if ret != 0:
        last_err, last_err_msg = get_last_error()
        assert ret == last_err and ret in TIE_ERROR_TO_PYTHON_EXCEPTION
        return TIE_ERROR_TO_PYTHON_EXCEPTION[ret](last_err, last_err_msg)
    return None


@lru_cache()
def get_python_object_from_handle(tie_type_name, handle_value, manage_handle):
    if handle_value is None or handle_value == 0:
        return None

    taichi = __import__("taichi")
    assert isinstance(handle_value, int)
    if manage_handle:  # TieXXXHandle
        assert tie_type_name.startswith("Tie")
        assert tie_type_name.endswith("Handle")
        typename = tie_type_name[3:-6]
        if typename in TIE_TEMP_CCORE_TYPE_TO_CORE_TYPE:
            return eval(f"{TIE_TEMP_CCORE_TYPE_TO_CORE_TYPE[typename]}.from_handle_to_object({handle_value})")
        return eval(f"taichi._lib.ccore.{typename}(handle={handle_value}, manage_handle=True)")
    else:  # TieXXXRef
        assert tie_type_name.startswith("Tie")
        assert tie_type_name.endswith("Ref")
        typename = tie_type_name[3:-3]
        if typename in TIE_TEMP_CCORE_TYPE_TO_CORE_TYPE:
            return eval(f"{TIE_TEMP_CCORE_TYPE_TO_CORE_TYPE[typename]}.from_handle_to_ref({handle_value})")
        return eval(f"taichi._lib.ccore.{typename}(handle={handle_value}, manage_handle=False)")


def wrap_callback_to_c(callback):
    def wrapped():
        try:
            callback()
        except Exception as e:
            set_last_exception(e)
            return -1
        return 0
    return wrapped


__all__ = [
    "TieAPIError",
    "get_exception_to_throw_if_not_success",
    "get_python_object_from_handle",
    "wrap_callback_to_c",
]
