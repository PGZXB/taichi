# This file is auto-generated by misc/exports_to_py.py
# DO NOT edit this file manually!
# To regenerate this file, run:
#     python misc/exports_to_py.py

import ctypes
from .ccore import taichi_ccore
from .utils import get_exception_to_throw_if_not_success, get_python_object_from_handle, wrap_callback_to_c


from .global_functions import get_last_error

from .global_functions import set_pytype_tp_finalize


# Class Program
class Program:
    def __init__(self, *args, handle=None, manage_handle=False):
        if handle is not None:
            self._manage_handle = manage_handle
            self._handle = handle
        else:
            self._manage_handle = True
            self._handle = self.create(*args)

    def get_handle(self):
        return self._handle

    @staticmethod
    def create():
        ret_handle = ctypes.c_void_p()
        ret = taichi_ccore.tie_Program_create(ctypes.byref(ret_handle))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            ret_handle.value    
        )

    def destroy(self):
        ret = taichi_ccore.tie_Program_destroy(self.get_handle())
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    def finalize(self):
        ret = taichi_ccore.tie_Program_finalize(self.get_handle())
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    def synchronize(self):
        ret = taichi_ccore.tie_Program_synchronize(self.get_handle())
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    def config(self):
        ret_config = ctypes.c_void_p()
        ret = taichi_ccore.tie_Program_config(self.get_handle(), ctypes.byref(ret_config))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            get_python_object_from_handle('TieCompileConfigRef', ret_config.value, manage_handle=False)    
        )

    def sync_kernel_profiler(self):
        ret = taichi_ccore.tie_Program_sync_kernel_profiler(self.get_handle())
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    def update_kernel_profiler(self):
        ret = taichi_ccore.tie_Program_update_kernel_profiler(self.get_handle())
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    def clear_kernel_profiler(self):
        ret = taichi_ccore.tie_Program_clear_kernel_profiler(self.get_handle())
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    def query_kernel_profile_info(self, name):
        ret_counter = ctypes.c_int()
        ret_min = ctypes.c_double()
        ret_max = ctypes.c_double()
        ret_avg = ctypes.c_double()
        ret = taichi_ccore.tie_Program_query_kernel_profile_info(self.get_handle(), name.encode("utf-8"), ctypes.byref(ret_counter), ctypes.byref(ret_min), ctypes.byref(ret_max), ctypes.byref(ret_avg))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            ret_counter.value,
        ret_min.value,
        ret_max.value,
        ret_avg.value    
        )

    def get_num_kernel_profiler_records(self):
        ret_size = ctypes.c_size_t()
        ret = taichi_ccore.tie_Program_get_num_kernel_profiler_records(self.get_handle(), ctypes.byref(ret_size))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            ret_size.value    
        )

    def get_kernel_profiler_record(self, index):
        ret_record = ctypes.c_void_p()
        ret = taichi_ccore.tie_Program_get_kernel_profiler_record(self.get_handle(), int(index), ctypes.byref(ret_record))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            get_python_object_from_handle('TieKernelProfileTracedRecordRef', ret_record.value, manage_handle=False)    
        )

    def get_kernel_profiler_device_name(self):
        ret_name = ctypes.c_void_p()
        ret = taichi_ccore.tie_Program_get_kernel_profiler_device_name(self.get_handle(), ctypes.byref(ret_name))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            get_python_object_from_handle('TieStringHandle', ret_name.value, manage_handle=True)    
        )

    def reinit_kernel_profiler_with_metrics(self, ap_metrics):
        ap_metrics = tuple(e.encode('utf-8') for e in ap_metrics)
        ap_metrics = (ctypes.c_char_p * len(ap_metrics))(*ap_metrics)
        ret_b = ctypes.c_int()
        ret = taichi_ccore.tie_Program_reinit_kernel_profiler_with_metrics(self.get_handle(), ap_metrics, len(ap_metrics), ctypes.byref(ret_b))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            bool(ret_b.value)    
        )

    def kernel_profiler_total_time(self):
        ret_time = ctypes.c_double()
        ret = taichi_ccore.tie_Program_kernel_profiler_total_time(self.get_handle(), ctypes.byref(ret_time))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            ret_time.value    
        )

    def set_kernel_profiler_toolkit(self, toolkit_name):
        ret_b = ctypes.c_int()
        ret = taichi_ccore.tie_Program_set_kernel_profiler_toolkit(self.get_handle(), toolkit_name.encode("utf-8"), ctypes.byref(ret_b))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            bool(ret_b.value)    
        )

    def timeline_clear(self):
        ret = taichi_ccore.tie_Program_timeline_clear(self.get_handle())
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    def timeline_save(self, fn):
        ret = taichi_ccore.tie_Program_timeline_save(self.get_handle(), fn.encode("utf-8"))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    def print_memory_profiler_info(self):
        ret = taichi_ccore.tie_Program_print_memory_profiler_info(self.get_handle())
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    def get_total_compilation_time(self):
        ret_time = ctypes.c_double()
        ret = taichi_ccore.tie_Program_get_total_compilation_time(self.get_handle(), ctypes.byref(ret_time))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            ret_time.value    
        )

    def get_snode_num_dynamically_allocated(self, snode):
        ret_size = ctypes.c_size_t()
        ret = taichi_ccore.tie_Program_get_snode_num_dynamically_allocated(self.get_handle(), snode.get_handle(), ctypes.byref(ret_size))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            ret_size.value    
        )

    def materialize_runtime(self):
        ret = taichi_ccore.tie_Program_materialize_runtime(self.get_handle())
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    def make_aot_module_builder(self, arch, ap_caps):
        ap_caps = tuple(e.encode('utf-8') for e in ap_caps)
        ap_caps = (ctypes.c_char_p * len(ap_caps))(*ap_caps)
        ret_handle = ctypes.c_void_p()
        ret = taichi_ccore.tie_Program_make_aot_module_builder(self.get_handle(), int(arch), ap_caps, len(ap_caps), ctypes.byref(ret_handle))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            get_python_object_from_handle('TieAotModuleBuilderHandle', ret_handle.value, manage_handle=True)    
        )

    def get_snode_tree_size(self):
        ret_size = ctypes.c_int()
        ret = taichi_ccore.tie_Program_get_snode_tree_size(self.get_handle(), ctypes.byref(ret_size))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            ret_size.value    
        )

    def get_snode_root(self, tree_id):
        ret_snode = ctypes.c_void_p()
        ret = taichi_ccore.tie_Program_get_snode_root(self.get_handle(), int(tree_id), ctypes.byref(ret_snode))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            get_python_object_from_handle('TieSNodeRef', ret_snode.value, manage_handle=False)    
        )

    def create_kernel(self, name, autodiff_mode):
        ret_kernel = ctypes.c_void_p()
        ret = taichi_ccore.tie_Program_create_kernel(self.get_handle(), name.encode("utf-8"), int(autodiff_mode), ctypes.byref(ret_kernel))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            get_python_object_from_handle('TieKernelRef', ret_kernel.value, manage_handle=False)    
        )

    def create_function(self, func_name, func_id, instance_id):
        ret_func = ctypes.c_void_p()
        ret = taichi_ccore.tie_Program_create_function(self.get_handle(), func_name.encode("utf-8"), int(func_id), int(instance_id), ctypes.byref(ret_func))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            get_python_object_from_handle('TieFunctionRef', ret_func.value, manage_handle=False)    
        )

    def create_sparse_matrix(self, n, m, dtype, storage_format):
        ret_handle = ctypes.c_void_p()
        ret = taichi_ccore.tie_Program_create_sparse_matrix(self.get_handle(), int(n), int(m), dtype.get_handle(), storage_format.encode("utf-8"), ctypes.byref(ret_handle))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            get_python_object_from_handle('TieSparseMatrixHandle', ret_handle.value, manage_handle=True)    
        )

    def make_sparse_matrix_from_ndarray(self, sm, ndarray):
        ret = taichi_ccore.tie_Program_make_sparse_matrix_from_ndarray(self.get_handle(), sm.get_handle(), ndarray.get_handle())
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    def create_ndarray(self, dt, ap_shape, external_array_layout, zero_fill):
        ap_shape = (ctypes.c_int * len(ap_shape))(*ap_shape)
        ret_handle = ctypes.c_void_p()
        ret = taichi_ccore.tie_Program_create_ndarray(self.get_handle(), dt.get_handle(), ap_shape, len(ap_shape), int(external_array_layout), bool(zero_fill), ctypes.byref(ret_handle))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            get_python_object_from_handle('TieNdarrayRef', ret_handle.value, manage_handle=False)    
        )

    def delete_ndarray(self, ndarray):
        ret = taichi_ccore.tie_Program_delete_ndarray(self.get_handle(), ndarray.get_handle())
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    def create_texture(self, fmt, ap_shape):
        ap_shape = (ctypes.c_int * len(ap_shape))(*ap_shape)
        ret_handle = ctypes.c_void_p()
        ret = taichi_ccore.tie_Program_create_texture(self.get_handle(), int(fmt), ap_shape, len(ap_shape), ctypes.byref(ret_handle))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            get_python_object_from_handle('TieTextureRef', ret_handle.value, manage_handle=False)    
        )

    def fill_ndarray_float(self, ndarray, f):
        ret = taichi_ccore.tie_Program_fill_ndarray_float(self.get_handle(), ndarray.get_handle(), float(f))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    def fill_ndarray_int(self, ndarray, i):
        ret = taichi_ccore.tie_Program_fill_ndarray_int(self.get_handle(), ndarray.get_handle(), int(i))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    def fill_ndarray_uint(self, ndarray, u):
        ret = taichi_ccore.tie_Program_fill_ndarray_uint(self.get_handle(), ndarray.get_handle(), int(u))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    def compile_kernel(self, compile_config, kernel):
        ret_ckd = ctypes.c_void_p()
        ret = taichi_ccore.tie_Program_compile_kernel(self.get_handle(), compile_config.get_handle(), kernel.get_handle(), ctypes.byref(ret_ckd))
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex
        return (
            get_python_object_from_handle('TieCompiledKernelDataRef', ret_ckd.value, manage_handle=False)    
        )

    def launch_kernel(self, kernel_data, ctx):
        ret = taichi_ccore.tie_Program_launch_kernel(self.get_handle(), kernel_data.get_handle(), ctx.get_handle())
        ex = get_exception_to_throw_if_not_success(ret, get_last_error)
        if ex is not None:
            raise ex

    num_kernel_profiler_records = property(get_num_kernel_profiler_records, None)
    kernel_profiler_device_name = property(get_kernel_profiler_device_name, None)
    total_compilation_time = property(get_total_compilation_time, None)
    snode_tree_size = property(get_snode_tree_size, None)


if hasattr(taichi_ccore, 'tie_Program_destroy'):
    destroy_fn_addr = ctypes.addressof(taichi_ccore.tie_Program_destroy)
    destroy_fn_addr = ctypes.c_void_p.from_address(destroy_fn_addr).value
    Program._tie_api_tp_finalize = destroy_fn_addr
    set_pytype_tp_finalize(id(Program))


__all__ = ['Program']
